CSCI 58000 - Program 5 F23

clear.txt - size: 484 bytes (484 bytes)

Part 1: Ninad Deshpande
1. Read text file "clear.txt"
2. Generate character counts for the text file from the standard ASCII 128 character set.
3. Write each character's non-zero occurence from "clear.txt" to "freq.txt".

Part 2: Arushi Pandit
1. Read text file "freq.txt"
2. Created huffman tree using min-priority queue on frequency counts
3. Wrote each character and its corresponding huffman code to "codetable.txt" ordered by ASCII values

Part 3A: --
1. Read codes from "codetable.txt". Generate unordered_map<char, string> codetable.
2. Read each character from "clear.txt", encode by finding the corresponding code from codetable.
3. Write coded value of character to "coded.txt". Continue until EOF for "clear.txt".

coded.txt - size: 2.03 KB (2,084 bytes)

Part 3B: --
1. Generate Huffman Tree from the unordered_map codetable.
2. Read each character from "coded.txt", traverse the Huffman Tree from root, moving left/right based on input '0' or '1' until a leaf is reached.
3. Write the character corresponding to the leaf to "decoded.txt", reset the pointer to root. Continue until EOF for "coded.txt".

decoded.txt - size: 484 bytes (484 bytes)

Part 4A: Sarth Kulkarni, Ninad Deshpande, Arushi Pandit
1. Using the unordered_map codetable from part 3A, match the corresponding code for each character from "clear.txt"
2. set() and reset() bits in a bitset<8> byte according to the codes, using a counter for indexing the active bit.
3. After every 8 bits encoded in the bitset, convert the bitset to char and store in "codedalt.txt"
4. For any leftover bits encoded in the bitset after the last character in "clear.txt" reset the unused bits and push the char to "codedalt.txt"

codedalt.txt - size: 261 bytes (261 bytes)

Part 4B: --
